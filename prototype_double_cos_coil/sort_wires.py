# Jared Brewington
# Date: Oct. 24, 2019
# 
# Wire sorting code takes a list of points with equipotential levels output from Comsol contour plots and separates them into individual wires
# The code will search for the contours in folders corresponding to each coil for a specified number of coils
# The coils must have axis aligned with x-axis
# The individual wires will be stored as lists of points in a file (e.g. "wire1.txt" for the first wire of a coil)
#
# this code reads parameters from file which is generated by another script: "update_params.py"

import numpy as np
import os
from send2trash import send2trash
from time import time
import update_params

startTime = time()

def get_separateWires(wiresFile):
    
    x, y, z, Iso = np.loadtxt(wiresFile, unpack=True)

    uniqueIso = np.unique(Iso)
    
    wireLists = [[] for x in uniqueIso]
    
    for x,y,z,Iso in zip(x,y,z,Iso):
        for i, level in enumerate(uniqueIso):
            if Iso == level: 
                wireLists[i].append([x,y,z,Iso])

    return wireLists


def write_wireToFile(fileName, wire, openType='w'):
    
    with open(fileName, openType) as f:
            for point in wire:
                f.write('%.12f %.12f %.12f\n' %(point[0], point[1], point[2]))


def sort_layer(coilFolder, wiresFile, wireIsoLevel, sortReverse=False, sortRad=False, centerYZ=[0,0], sortY = False, openType='a'): 
    
    wireLists = get_separateWires(wiresFile)

    const = 1
    if sortReverse: const *= -1

    if sortRad:
        key = lambda l: const * ( (l[1]-centerYZ[0])**2 + (l[2]-centerYZ[1])**2 )
    elif sortY:
        key = lambda l: const * l[1]
    else:
        key = lambda l: const*l[0]

    for wire in wireLists:
        for j in range(len(wireIsoLevel)):
            if abs(wireIsoLevel[j] - wire[0][3]) < 1E-6:
                wire = sorted(wire, key=key)
                wireFile = coilFolder+'/wires/wire'+str(j+1)+'.txt'
                write_wireToFile(wireFile, wire, openType=openType)
                break


def get_dist2(p1, p2):
    
    """returns squared distance between points 1 and 2 in 3D
    """
    x = p1[0]-p2[0]
    y = p1[1]-p2[1]
    z = p1[2]-p2[2]
    return x*x+y*y+z*z


def get_dist(p1,p2):
    """ returns distance between 2 points p1,p2 in 3D
    """
    return get_dist2(p1,p2)**.5


def main():
    # Read in parameters from file

    update_params.set_params()

    with open('parameters.txt') as f:
        params = [float(x) for x in f.readlines()]

    numCoils = int(params[0])
    outRad = params[1]
    inRad = params[2]
    coilPos = params[3:6]
    coilLength = params[6:6+numCoils]
    coilGap = params[6+numCoils]

    print(coilLength)
    print(coilGap)


    # get folders where wires are stored

    coilFolders = sorted([x for x in os.listdir('.') if os.path.isdir(x) and 'coil' in x])
    if len(coilFolders) > numCoils:     # limit list to number of coils specified in params file
        coilFolders = coilFolders[:numCoils]

    # sort contours by surface (inner, outer, and endcaps) for each coil and relative current in each coil

    wireIsoLevel = list()   # this will be used to make sure that each wire file only contains points with same equipotential value
    currentList = list()    # list of relative currents in the coils
    for i, coilFolder in enumerate(coilFolders):

        print(coilFolder)

        # clear the directory storing wire files
        wireDir = coilFolder + '/wires/'
        for file in os.listdir(wireDir):
            send2trash(wireDir+file)

        # objects to write points to proper file
        comsolWireDir = coilFolder+'/wires_from_model/'
        f1 = open(comsolWireDir + 'posEndcap.txt','w')
        f2 = open(comsolWireDir + 'negEndcap.txt','w')
        f3 = open(comsolWireDir + 'outerLayer.txt','w')
        f4 = open(comsolWireDir + 'innerLayer.txt','w')
        f5 = open(comsolWireDir + 'unsorted.txt','w')

        # load data from file containing all contours from Comsol
        unseparatedWires = comsolWireDir + 'unsepWires.txt'
        X,Y,Z,ISO = np.loadtxt(unseparatedWires, unpack=True)
        wireIsoLevel = sorted(np.unique(ISO))     # each contour corresponds to a particular wire given by index of this list
        currentList.append(max(wireIsoLevel)-min(wireIsoLevel))

        # variables for center of coil in yz plane and the x position of each end of the current coil
        y0, z0 = coilPos[1], coilPos[2]
        x0neg = coilPos[0]+sum(coilLength[0:i])
        x0pos = x0neg+coilLength[i]-coilGap

        count = 0
        for x,y,z,Iso in zip(X,Y,Z,ISO):

            if abs( x-x0pos ) < 1E-10:      # point is on positive endcap
                f1.write('%.12f\t%.12f\t%.12f\t%.12f\n' %(x,y,z,Iso))
            
            elif abs( x-x0neg ) < 1E-10:    # point is on negative endcap
                f2.write('%.12f\t%.12f\t%.12f\t%.12f\n' %(x,y,z,Iso))

            elif abs( (y-y0)**2+(z-z0)**2 - outRad**2 ) < 1E-4:     # point is on outer surface
                f3.write('%.12f\t%.12f\t%.12f\t%.12f\n' %(x,y,z,Iso))

            elif abs( (y-y0)**2 + (z-z0)**2 - inRad**2 ) < 1E-4:    # point is on inner surface
                f4.write('%.12f\t%.12f\t%.12f\t%.12f\n' %(x,y,z,Iso))
            
            else:           # point is unsorted--not good
                count += 1
                f5.write('%.12f\t%.12f\t%.12f\t%.12f\n' %(x,y,z,Iso))

        f1.close()
        f2.close()
        f3.close()
        f4.close()
        f5.close()

        print('Unsorted count should be zero: count = %d' %count)

        
        # sort wire points and get the current value for each coil

        # negative endcap
        wiresFile = coilFolder+'/wires_from_model/'+'negEndcap.txt'
        sort_layer(coilFolder, wiresFile, wireIsoLevel, sortRad=True)

        # Outer layer
        wiresFile = coilFolder+'/wires_from_model/'+'outerLayer.txt'
        sort_layer(coilFolder, wiresFile,  wireIsoLevel)

        # positive endcap
        wiresFile = coilFolder+'/wires_from_model/'+'posEndcap.txt'
        sort_layer(coilFolder, wiresFile, wireIsoLevel, sortRad=True, sortReverse=True)
        
        # inner layer pos
        wiresFile = coilFolder+'/wires_from_model/'+'innerLayer.txt'
        sort_layer(coilFolder, wiresFile, wireIsoLevel, sortReverse=True)

        # check inner layer for break and complete closed loops
        # if wire hits symmetry plane twice on inner surface, sorting was improper
        # also any closed loops need to be completed by connecting first and last points
        wireFolder = coilFolder + '/wires/'
        for wire in os.listdir(wireFolder):
           
            # check if there is a large jump in x between two adjacent points 

            filePath = wireFolder + wire
            x,y,z = np.loadtxt(filePath, unpack=True)
            
            for j in range(len(x[1:-1])):
                p1 = [x[j],y[j],z[j]]
                p2 = [x[j+1],y[j+1],z[j+1]]
                if get_dist(p1, p2) > .012:    # if there is a break, all points that come after the break will be resorted to the beginning of the wire
                    
                    with open(filePath, 'w') as f:
                        for px,py,pz in zip(x[j+1:],y[j+1:],z[j+1:]):
                            f.write('%.12f\t%.12f\t%.12f\n' %(px,py,pz))

                        for px,py,pz in zip(x[:j+1],y[:j+1],z[:j+1]):
                            f.write('%.12f\t%.12f\t%.12f\n' %(px,py,pz))

                    break
            
            # if the initial and final points are nearly touching (signifying closed loop)
            # then append inital point to end of file to complete the loop

            x,y,z = np.loadtxt(filePath, unpack=True)
                        
            p1 = [x[0],y[0],z[0]]
            p2 = [x[-1],y[-1],z[-1]]
            
            if get_dist(p1, p2) < .005 and get_dist([0,p1[1],p1[2]], [0,p2[1],p2[2]]) < 1E-3:
                with open(filePath,'a') as f:
                    f.write('%.12f\t%.12f\t%.12f\n' %(x[0],y[0],z[0]))


        # final check for order of points
        # the next point should be closer than the next next point
        # also option to change size of file (e.g. delete every other point)

        orderCount = 0

        for wire in os.listdir(wireFolder):
            
            sortTime = time()

            wirePath = wireFolder + wire
            x,y,z = np.loadtxt(wirePath, unpack=True)

            breakPoint = int(len(x)/2)

            for k in range(breakPoint):
                if y[k] == 0:
                    x = np.append(x[k::-1],x[k+1:])
                    y = np.append(y[k::-1],y[k+1:])
                    z = np.append(z[k::-1],z[k+1:])
                    breakPoint = len(x)-k
                    break
            
            for n in range(1,breakPoint-1):
                if y[-n] == 0:
                    x = np.append(x[:-n],x[-1:-(n+1):-1])
                    y = np.append(y[:-n],y[-1:-(n+1):-1])
                    z = np.append(z[:-n],z[-1:-(n+1):-1])
                    break

            # # attempt to order wires
            # orderFlag = True
            # startInd = 1
            # while orderFlag:
            #     for i in range(startInd, len(x)-2):
            #         genInd = (i+10)%len(x)
            #         p1 = [x[i],y[i],z[i]]
            #         p2 = [x[i+1],y[i+1],z[i+1]]
            #         p3 = [x[genInd],y[genInd],z[genInd]]

                    
            #         p1p2 = [a-b for a,b in zip(p1,p2)]
            #         p2p3 = [a-b for a,b in zip(p2,p3)]
            #         p1p3 = [a-b for a,b in zip(p1,p3)]

            #         while np.dot(p1p3, p2p3) < 0:
            #             genInd = (genInd+1)%len(x)
            #             p3 = [x[genInd],y[genInd],z[genInd]]
            #             p2p3 = [a-b for a,b in zip(p2,p3)]
            #             p1p3 = [a-b for a,b in zip(p1,p3)]

            #         if np.dot(p1p2, p1p3) <0:
            #             orderCount += 1
            #             x[i+1],y[i+1],z[i+1] = p1
            #             x[i],y[i],z[i] = p2
            #             startInd = max(1, i-2)
            #             break
            #     else:
            #         orderFlag = False

            #     if time()-sortTime > 1.5:
            #         print(wire)
            #         break


            # # organize first half

            # orderFlag = True
            # startInd = 0
            # while orderFlag:
            #     for i in range(startInd, breakPoint):

            #         p1 = [x[i],y[i],z[i]]
            #         p2 = [x[i+1],y[i+1],z[i+1]]
            #         p3 = [x[i+2],y[i+2],z[i+2]]

            #         if i==0 and y[i]==0.0:
            #             startInd = 1
            #             break

            #         p1p2 = [a-b for a,b in zip(p1,p2)]
            #         p2p3 = [a-b for a,b in zip(p2,p3)]
            #         p1p3 = [a-b for a,b in zip(p1,p3)]

            #         if np.dot(p1p2, p1p3) < 0 or np.dot(p2p3,p1p3) < 0:
            #         # if np.dot(p2p3, p1p3) < 0:
            #             orderCount += 1
            #             x[i+1],y[i+1],z[i+1] = p1
            #             x[i],y[i],z[i] = p2
            #             startInd = max(0, i-1)
            #             break
            #     else:
            #         orderFlag = False

            #     if time()-sortTime > 1.5:
            #         print(wire)
            #         break

            # # organize second half
            
            # orderFlag = True
            # startInd = breakPoint
            # while orderFlag:
            #     for i in range(startInd, len(x)-2):
                
            #         p1 = [x[i],y[i],z[i]]
            #         p2 = [x[i+1],y[i+1],z[i+1]]
            #         p3 = [x[i+2],y[i+2],z[i+2]]

            #         if p2==p3:
            #             x = np.delete(x, i+2)
            #             y = np.delete(y, i+2)
            #             z = np.delete(z, i+2)
            #             break

            #         p1p2 = [a-b for a,b in zip(p1,p2)]
            #         p2p3 = [a-b for a,b in zip(p2,p3)]
            #         p1p3 = [a-b for a,b in zip(p1,p3)]

            #         if np.dot(p1p2, p1p3) < 0 or np.dot(p2p3,p1p3) < 0:
            #         # if np.dot(p1p2, p1p3) < 0:
            #             orderCount += 1
            #             x[i+1],y[i+1],z[i+1] = p3
            #             x[i+2],y[i+2],z[i+2] = p2
            #             startInd = max(1,i - 1)
            #             break
            #     else:
            #         orderFlag = False

            #     if time()-sortTime > 3:
            #         print(wire)
            #         break
            
            # delete points from list...make sure endpoints don't change

            divisor = 3   # must be int
            if len(x)%divisor == 1 or divisor == 1:
                x, y, z = x[::divisor], y[::divisor], z[::divisor]
            else:
                x0, y0, z0 = x[-1], y[-1], z[-1]
                x, y, z = x[::divisor], y[::divisor], z[::divisor]
                x = np.append(x, x0)
                y = np.append(y, y0)
                z = np.append(z, z0)

            write_wireToFile(wirePath, zip(x,y,z))

            # print('Order check:', orderCount)

    ######## end for loop over coils

    normalizedCurrents = currentList/max(currentList)
    with open('normalizedCurrents.txt', 'w') as f:
        for cur in normalizedCurrents:
            f.write('%.8f \n' %cur)
    print('Normalized relative currents: ', normalizedCurrents)

    print('Time elapsed: %.0f seconds' %(time()-startTime))




if __name__ == '__main__':
    main()